# 函数注解

JS的函数可以可以任意多条语句，而且可以在任何地方任何时候调用执行。ECMAScript用的函数使用function关键字来声明，后面跟一组参数以及函数体。基本语法如下

```
function functionName (arg0, arg1, ..., argN) {
  statements
}
```

## 函数调用

第一种调用方式：函数调用

```
function a () {
  console.log('test')
}
```

这是一个最简单的函数,不关联任何一个对象。同时上下文（this）非严格模式默认是属于全局对象window，在严格模式是undefined。另外这是一个全局的函数，容易产生命名冲突。

第二种调用方式：方法调用

```
let a = {
  name: 'test',
  fn: function () {
    console.log('test')
  }
}
```

这是普通的对象， 里面创建个name属性和fn函数，更多的情况都是将函数作为对象的方法使用，避免命名冲突。上下文（this）指向最后调用他的那个对象。

匿名函数的上下文（this）永远指向window，这个时候this被指向最后调用的它的那个对象，但是它没有名字，所以匿名函数的上下文（this）永远指向 window

箭头函数和普通的函数上下文（this）是有区别的，箭头函数的上下文（this）始终指向函数定义时的 this，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。

第三种调用方式：构造函数

函数调用前使用了new关键字，则是把这个函数当成构造函数来使用。惯例构造函数第一个字母大写，普通函数小写开头。

```
function Person (name, age, job) {
  this.name = name
  this.age = age
  this.jop = jop
  this.sayName = function () {
    console.log(this.name)
  }
}
```

和第二种一样，区别在于实现不一样而已。这里就会引发另外一个问题，new关键字做了什么。

1. 创建一个新对象 let obj = {}
2. 将构造函数的作用域赋给了this对象 obj.__proto = functionName.prototype
3. 为这个新对象添加属性 functionName.apply(obj, [...args])
4. 如果该函数没有返回对象，则返回this

代码实现

```
function newFns (args) {
  if (typeof args !== 'function') {
    throw 'newFns function the first param must be a function'
  }
  var obj = {}
  obj.__proto = args.prototype
  var argsArr = [].slice.call(arguments, 1)
  var result = args.apply(obj, argsArr)
  var isObj = typeof result === 'object' && result !== null
  var isFunction = typeof result === 'function
  if (!isObj || isFunction) {
    return result
  }
  return obj
}
```

原型链是什么，就是函数的原型被指向一个构造函数的实例的原型。当自身的实例找不到属性或者方法，就往上一层的原型寻找属性或者方法，这就是原型。

每个构造函数都有一个原型对象，原型对象里面都有一个包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。这个时候我们让原型对象等于另外一个类型的实例，此刻原型对象将包含另外一个原型的指针。